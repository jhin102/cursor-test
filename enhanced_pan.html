<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìì—°ìŠ¤ëŸ¬ìš´ ë””ì§€í„¸ í•„ê¸°</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 30px;
            max-width: 90vw;
            width: 100%;
            max-width: 1000px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        .canvas-container {
            border: 3px solid #eee;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
            background: #fafafa;
            position: relative;
        }

        #drawingCanvas {
            display: block;
            cursor: crosshair;
            background: white;
            touch-action: none;
        }

        .status {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            font-size: 0.9em;
            color: #666;
        }

        .features {
            margin-top: 20px;
            padding: 20px;
            background: #f0f8ff;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .features h3 {
            margin-top: 0;
            color: #333;
        }

        .features ul {
            margin: 0;
            padding-left: 20px;
        }

        .features li {
            margin-bottom: 5px;
            color: #555;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-group {
                justify-content: space-between;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ–‹ï¸ ìì—°ìŠ¤ëŸ¬ìš´ ë””ì§€í„¸ í•„ê¸°</h1>
        <p class="subtitle">ì••ë ¥ ê°ì§€, ìŠ¤ë¬´ë”©, ì˜ˆì¸¡ ë Œë”ë§ ê¸°ìˆ ë¡œ ì‹¤ì œ íœê³¼ ê°™ì€ í•„ê¸° ê²½í—˜</p>
        
        <div class="controls">
            <div class="control-group">
                <label for="brushSize">íœ êµµê¸°:</label>
                <input type="range" id="brushSize" min="1" max="20" value="3">
                <span id="brushSizeValue">3px</span>
            </div>
            
            <div class="control-group">
                <label for="color">ìƒ‰ìƒ:</label>
                <input type="color" id="color" value="#2c3e50">
            </div>
            
            <div class="control-group">
                <label for="smoothing">ìŠ¤ë¬´ë”©:</label>
                <input type="range" id="smoothing" min="0" max="10" value="5">
                <span id="smoothingValue">5</span>
            </div>
            
            <div class="control-group">
                <label for="pressureSensitivity">ì••ë ¥ ê°ë„:</label>
                <input type="range" id="pressureSensitivity" min="0" max="10" value="7">
                <span id="pressureValue">7</span>
            </div>
            
            <button onclick="clearCanvas()">ì§€ìš°ê¸°</button>
        </div>

        <div class="canvas-container">
            <canvas id="drawingCanvas" width="800" height="500"></canvas>
        </div>

        <div class="status">
            <div>ë§ˆì§€ë§‰ ìŠ¤íŠ¸ë¡œí¬: <span id="lastStroke">-</span></div>
            <div>í™œì„± í¬ì¸íŠ¸: <span id="activePoints">0</span></div>
            <div>ë Œë”ë§ FPS: <span id="fps">60</span></div>
        </div>

        <div class="features">
            <h3>êµ¬í˜„ëœ ìì—°ìŠ¤ëŸ¬ìš´ í•„ê¸° ê¸°ìˆ </h3>
            <ul>
                <li><strong>ì••ë ¥ ê°ì§€ ì‹œë®¬ë ˆì´ì…˜</strong> - ë§ˆìš°ìŠ¤ ì†ë„ë¡œ ì••ë ¥ ì¶”ì •, ë™ì  ì„  êµµê¸°</li>
                <li><strong>ë² ì§€ì–´ ê³¡ì„  ìŠ¤ë¬´ë”©</strong> - ì‹¤ì‹œê°„ ê³¡ì„  ë³´ê°„ìœ¼ë¡œ ë¶€ë“œëŸ¬ìš´ ì„ </li>
                <li><strong>ì§€ì—° ìµœì†Œí™”</strong> - ê³ ì£¼ì‚¬ìœ¨ ë Œë”ë§ê³¼ ìµœì í™”ëœ ë“œë¡œì‰</li>
                <li><strong>ì ì‘í˜• ìƒ˜í”Œë§</strong> - ì†ë„ì— ë”°ë¥¸ ë™ì  í¬ì¸íŠ¸ ê°„ê²© ì¡°ì •</li>
                <li><strong>ìì—°ìŠ¤ëŸ¬ìš´ ì‹œì‘/ë</strong> - ìŠ¤íŠ¸ë¡œí¬ì˜ ìì—°ìŠ¤ëŸ¬ìš´ êµµê¸° ë³€í™”</li>
                <li><strong>ê³ ì„±ëŠ¥ ë Œë”ë§</strong> - 60FPS ë¶€ë“œëŸ¬ìš´ ì‹¤ì‹œê°„ ë“œë¡œì‰</li>
            </ul>
        </div>
    </div>

    <script>
        class NaturalPen {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.isDrawing = false;
                this.currentStroke = [];
                this.lastPoint = null;
                this.lastTime = 0;
                this.velocity = 0;
                this.predictedPoint = null;
                
                // ì••ë ¥ ìŠ¤ë¬´ë”©ì„ ìœ„í•œ ë³€ìˆ˜ë“¤
                this.velocityHistory = [];
                this.pressureHistory = [];
                this.lastPressure = 0.5;
                
                // ì„¤ì •ê°’
                this.brushSize = 3;
                this.color = '#2c3e50';
                this.smoothingFactor = 0.5;
                this.pressureSensitivity = 0.7;
                
                // ì„±ëŠ¥ ì¸¡ì •
                this.frameCount = 0;
                this.lastFpsTime = performance.now();
                
                this.setupEventListeners();
                this.startRenderLoop();
            }

            setupEventListeners() {
                // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDrawing());
                this.canvas.addEventListener('mouseleave', () => this.stopDrawing());

                // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼)
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const mouseEvent = new MouseEvent('mouseup', {});
                    this.canvas.dispatchEvent(mouseEvent);
                });
            }

            getCanvasPoint(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY,
                    time: performance.now()
                };
            }

            calculatePressure(velocity, isEnding = false) {
                // ìŠ¤íŠ¸ë¡œí¬ ëì—ì„œëŠ” ì••ë ¥ì„ ì ì§„ì ìœ¼ë¡œ ê°ì†Œ
                if (isEnding) {
                    return Math.max(0.1, this.lastPressure * 0.3);
                }
                
                // ì†ë„ íˆìŠ¤í† ë¦¬ ê´€ë¦¬ (ìµœê·¼ 5ê°œ í¬ì¸íŠ¸)
                this.velocityHistory.push(velocity);
                if (this.velocityHistory.length > 5) {
                    this.velocityHistory.shift();
                }
                
                // í‰ê·  ì†ë„ ê³„ì‚° (ê¸‰ê²©í•œ ë³€í™” ë°©ì§€)
                const avgVelocity = this.velocityHistory.reduce((sum, v) => sum + v, 0) / this.velocityHistory.length;
                
                // ì†ë„ ê¸°ë°˜ ì••ë ¥ ê³„ì‚°
                const maxVelocity = 800;
                const normalizedVelocity = Math.min(avgVelocity / maxVelocity, 1);
                const basePressure = 0.4;
                const pressureRange = 0.5;
                
                // ë°©í–¥ ì „í™˜ì„ ê³ ë ¤í•œ ì••ë ¥ ê³„ì‚°
                let rawPressure = basePressure + pressureRange * (1 - normalizedVelocity) * this.pressureSensitivity;
                
                // ì••ë ¥ ìŠ¤ë¬´ë”© (ì´ì „ ì••ë ¥ê³¼ ë¶€ë“œëŸ½ê²Œ ë¸”ë Œë”©)
                const pressureSmoothingFactor = 0.7;
                const smoothedPressure = this.lastPressure * pressureSmoothingFactor + rawPressure * (1 - pressureSmoothingFactor);
                
                this.lastPressure = smoothedPressure;
                return Math.max(0.2, Math.min(1.0, smoothedPressure));
            }

            calculateVelocity(currentPoint, lastPoint) {
                if (!lastPoint) return 0;
                
                const dx = currentPoint.x - lastPoint.x;
                const dy = currentPoint.y - lastPoint.y;
                const dt = Math.max(currentPoint.time - lastPoint.time, 1);
                
                const distance = Math.sqrt(dx * dx + dy * dy);
                const currentVelocity = distance / dt * 1000; // pixels per second
                
                // ì†ë„ ìŠ¤ë¬´ë”© (ê¸‰ê²©í•œ ë³€í™” ë°©ì§€)
                const velocitySmoothingFactor = 0.8;
                this.velocity = this.velocity * velocitySmoothingFactor + currentVelocity * (1 - velocitySmoothingFactor);
                
                return this.velocity;
            }

            predictNextPoint(currentPoint, lastPoint) {
                if (!lastPoint) return currentPoint;
                
                const dx = currentPoint.x - lastPoint.x;
                const dy = currentPoint.y - lastPoint.y;
                
                // ì˜ˆì¸¡ ê±°ë¦¬ëŠ” í˜„ì¬ ì†ë„ì— ë¹„ë¡€
                const predictionFactor = Math.min(this.velocity / 500, 2);
                
                return {
                    x: currentPoint.x + dx * predictionFactor,
                    y: currentPoint.y + dy * predictionFactor,
                    time: currentPoint.time
                };
            }

            smoothPoint(currentPoint, lastPoint, factor) {
                if (!lastPoint) return currentPoint;
                
                return {
                    x: lastPoint.x + (currentPoint.x - lastPoint.x) * factor,
                    y: lastPoint.y + (currentPoint.y - lastPoint.y) * factor,
                    time: currentPoint.time
                };
            }

            startDrawing(e) {
                this.isDrawing = true;
                const point = this.getCanvasPoint(e);
                this.currentStroke = [point];
                this.lastPoint = point;
                this.lastTime = point.time;
                
                // ì••ë ¥ ê´€ë ¨ ë³€ìˆ˜ ì´ˆê¸°í™”
                this.velocityHistory = [0];
                this.pressureHistory = [];
                this.lastPressure = 0.5;
                this.velocity = 0;
                
                document.getElementById('activePoints').textContent = '1';
            }

            draw(e) {
                if (!this.isDrawing) return;

                const rawPoint = this.getCanvasPoint(e);
                
                // ì†ë„ ê³„ì‚°
                this.velocity = this.calculateVelocity(rawPoint, this.lastPoint);
                
                // ìŠ¤ë¬´ë”© ì ìš©
                const smoothedPoint = this.smoothPoint(rawPoint, this.lastPoint, this.smoothingFactor);
                
                // ì••ë ¥ ê³„ì‚°
                const pressure = this.calculatePressure(this.velocity);
                
                // ì˜ˆì¸¡ í¬ì¸íŠ¸ ê³„ì‚° (ë Œë”ë§í•˜ì§€ ì•ŠìŒ)
                this.predictedPoint = this.predictNextPoint(smoothedPoint, this.lastPoint);
                
                // ë² ì§€ì–´ ê³¡ì„ ìœ¼ë¡œ ë¶€ë“œëŸ¬ìš´ ì„  ê·¸ë¦¬ê¸°
                if (this.lastPoint) {
                    this.drawSmoothLine(this.lastPoint, smoothedPoint, pressure);
                }
                
                this.currentStroke.push(smoothedPoint);
                this.lastPoint = smoothedPoint;
                
                // UI ì—…ë°ì´íŠ¸
                document.getElementById('activePoints').textContent = this.currentStroke.length;
            }

            drawSmoothLine(from, to, pressure) {
                const distance = Math.sqrt(
                    Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2)
                );
                
                // ê±°ë¦¬ê°€ ë„ˆë¬´ ì‘ìœ¼ë©´ ìŠ¤í‚µ
                if (distance < 1) return;
                
                // ì••ë ¥ì— ë”°ë¥¸ ì„  êµµê¸°
                const lineWidth = this.brushSize * pressure;
                
                // ì²« ë²ˆì§¸ ì ì¸ ê²½ìš° ì§ì„ ìœ¼ë¡œ ì‹œì‘
                if (this.currentStroke.length === 0) {
                    this.ctx.lineWidth = lineWidth;
                    this.ctx.strokeStyle = this.color;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(from.x, from.y);
                    this.ctx.lineTo(to.x, to.y);
                    this.ctx.stroke();
                    return;
                }
                
                // ë² ì§€ì–´ ê³¡ì„  ì œì–´ì  ê³„ì‚°
                const cp1x = from.x + (to.x - from.x) * 0.3;
                const cp1y = from.y + (to.y - from.y) * 0.3;
                const cp2x = from.x + (to.x - from.x) * 0.7;
                const cp2y = from.y + (to.y - from.y) * 0.7;
                
                this.ctx.lineWidth = lineWidth;
                this.ctx.strokeStyle = this.color;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                this.ctx.beginPath();
                this.ctx.moveTo(from.x, from.y);
                this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, to.x, to.y);
                this.ctx.stroke();
            }

            stopDrawing() {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                
                // ìì—°ìŠ¤ëŸ¬ìš´ ìŠ¤íŠ¸ë¡œí¬ ëì²˜ë¦¬ - ë§ˆì§€ë§‰ ëª‡ ê°œì˜ ì ì— í…Œì´í¼ ì ìš©
                if (this.currentStroke.length > 2 && this.lastPoint) {
                    this.addNaturalEnding();
                }
                
                // í†µê³„ ì—…ë°ì´íŠ¸
                const strokeLength = this.currentStroke.length;
                const avgVelocity = Math.round(this.velocity);
                document.getElementById('lastStroke').textContent = 
                    `${strokeLength}ì , ${avgVelocity}px/s`;
                document.getElementById('activePoints').textContent = '0';
                
                this.currentStroke = [];
                this.lastPoint = null;
                this.predictedPoint = null;
            }

            addNaturalEnding() {
                // ë§ˆì§€ë§‰ í¬ì¸íŠ¸ë¶€í„° ì ì§„ì ìœ¼ë¡œ ì••ë ¥ì„ ì¤„ì—¬ì„œ ìì—°ìŠ¤ëŸ¬ìš´ ëì²˜ë¦¬
                if (this.currentStroke.length < 3) return;
                
                const endPoints = 3; // ë§ˆì§€ë§‰ 3ê°œ ì ì— í…Œì´í¼ ì ìš©
                const startIndex = Math.max(0, this.currentStroke.length - endPoints);
                
                for (let i = startIndex; i < this.currentStroke.length - 1; i++) {
                    const progress = (i - startIndex) / endPoints;
                    const taperPressure = this.calculatePressure(this.velocity, true) * (1 - progress * 0.6);
                    
                    const from = this.currentStroke[i];
                    const to = this.currentStroke[i + 1];
                    
                    if (from && to) {
                        this.ctx.lineWidth = this.brushSize * Math.max(0.1, taperPressure);
                        this.ctx.strokeStyle = this.color;
                        this.ctx.lineCap = 'round';
                        this.ctx.lineJoin = 'round';
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(from.x, from.y);
                        this.ctx.lineTo(to.x, to.y);
                        this.ctx.stroke();
                    }
                }
            }

            startRenderLoop() {
                const renderFrame = () => {
                    // FPS ê³„ì‚°
                    this.frameCount++;
                    const now = performance.now();
                    if (now - this.lastFpsTime >= 1000) {
                        const fps = Math.round(this.frameCount * 1000 / (now - this.lastFpsTime));
                        document.getElementById('fps').textContent = fps;
                        this.frameCount = 0;
                        this.lastFpsTime = now;
                    }
                    
                    requestAnimationFrame(renderFrame);
                };
                
                renderFrame();
            }

            // ì„¤ì • ì—…ë°ì´íŠ¸ ë©”ì„œë“œë“¤
            setBrushSize(size) {
                this.brushSize = parseFloat(size);
            }

            setColor(color) {
                this.color = color;
            }

            setSmoothing(value) {
                this.smoothingFactor = parseFloat(value) / 10;
            }

            setPressureSensitivity(value) {
                this.pressureSensitivity = parseFloat(value) / 10;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }

        // ì´ˆê¸°í™”
        const canvas = document.getElementById('drawingCanvas');
        const pen = new NaturalPen(canvas);

        // ì»¨íŠ¸ë¡¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('brushSize').addEventListener('input', (e) => {
            pen.setBrushSize(e.target.value);
            document.getElementById('brushSizeValue').textContent = e.target.value + 'px';
        });

        document.getElementById('color').addEventListener('input', (e) => {
            pen.setColor(e.target.value);
        });

        document.getElementById('smoothing').addEventListener('input', (e) => {
            pen.setSmoothing(e.target.value);
            document.getElementById('smoothingValue').textContent = e.target.value;
        });

        document.getElementById('pressureSensitivity').addEventListener('input', (e) => {
            pen.setPressureSensitivity(e.target.value);
            document.getElementById('pressureValue').textContent = e.target.value;
        });

        function clearCanvas() {
            pen.clear();
            document.getElementById('lastStroke').textContent = '-';
            document.getElementById('activePoints').textContent = '0';
        }

        // ì´ˆê¸° ê°’ ì„¤ì •
        document.getElementById('brushSizeValue').textContent = '3px';
        document.getElementById('smoothingValue').textContent = '5';
        document.getElementById('pressureValue').textContent = '7';
    </script>
</body>
</html>