<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자연스러운 디지털 필기</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 30px;
            max-width: 90vw;
            width: 100%;
            max-width: 1000px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        .canvas-container {
            border: 3px solid #eee;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
            background: #fafafa;
            position: relative;
        }

        #drawingCanvas {
            display: block;
            cursor: crosshair;
            background: white;
            touch-action: none;
        }

        .status {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            font-size: 0.9em;
            color: #666;
        }

        .features {
            margin-top: 20px;
            padding: 20px;
            background: #f0f8ff;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .features h3 {
            margin-top: 0;
            color: #333;
        }

        .features ul {
            margin: 0;
            padding-left: 20px;
        }

        .features li {
            margin-bottom: 5px;
            color: #555;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-group {
                justify-content: space-between;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🖋️ 자연스러운 디지털 필기</h1>
        <p class="subtitle">압력 감지, 스무딩, 예측 렌더링 기술로 실제 펜과 같은 필기 경험</p>
        
        <div class="controls">
            <div class="control-group">
                <label for="brushSize">펜 굵기:</label>
                <input type="range" id="brushSize" min="1" max="20" value="3">
                <span id="brushSizeValue">3px</span>
            </div>
            
            <div class="control-group">
                <label for="color">색상:</label>
                <input type="color" id="color" value="#2c3e50">
            </div>
            
            <div class="control-group">
                <label for="smoothing">스무딩:</label>
                <input type="range" id="smoothing" min="0" max="10" value="5">
                <span id="smoothingValue">5</span>
            </div>
            
            <div class="control-group">
                <label for="pressureSensitivity">압력 감도:</label>
                <input type="range" id="pressureSensitivity" min="0" max="10" value="7">
                <span id="pressureValue">7</span>
            </div>
            
            <button onclick="clearCanvas()">지우기</button>
        </div>

        <div class="canvas-container">
            <canvas id="drawingCanvas" width="800" height="500"></canvas>
        </div>

        <div class="status">
            <div>마지막 스트로크: <span id="lastStroke">-</span></div>
            <div>활성 포인트: <span id="activePoints">0</span></div>
            <div>렌더링 FPS: <span id="fps">60</span></div>
        </div>

        <div class="features">
            <h3>구현된 자연스러운 필기 기술</h3>
            <ul>
                <li><strong>압력 감지 시뮬레이션</strong> - 마우스 속도로 압력 추정, 동적 선 굵기</li>
                <li><strong>베지어 곡선 스무딩</strong> - 실시간 곡선 보간으로 부드러운 선</li>
                <li><strong>지연 최소화</strong> - 고주사율 렌더링과 최적화된 드로잉</li>
                <li><strong>적응형 샘플링</strong> - 속도에 따른 동적 포인트 간격 조정</li>
                <li><strong>자연스러운 시작/끝</strong> - 스트로크의 자연스러운 굵기 변화</li>
                <li><strong>고성능 렌더링</strong> - 60FPS 부드러운 실시간 드로잉</li>
            </ul>
        </div>
    </div>

    <script>
        class NaturalPen {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.isDrawing = false;
                this.currentStroke = [];
                this.lastPoint = null;
                this.lastTime = 0;
                this.velocity = 0;
                this.predictedPoint = null;
                
                // 압력 스무딩을 위한 변수들
                this.velocityHistory = [];
                this.pressureHistory = [];
                this.lastPressure = 0.5;
                
                // 설정값
                this.brushSize = 3;
                this.color = '#2c3e50';
                this.smoothingFactor = 0.5;
                this.pressureSensitivity = 0.7;
                
                // 성능 측정
                this.frameCount = 0;
                this.lastFpsTime = performance.now();
                
                this.setupEventListeners();
                this.startRenderLoop();
            }

            setupEventListeners() {
                // 마우스 이벤트
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                this.canvas.addEventListener('mouseup', () => this.stopDrawing());
                this.canvas.addEventListener('mouseleave', () => this.stopDrawing());

                // 터치 이벤트 (모바일)
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.canvas.dispatchEvent(mouseEvent);
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const mouseEvent = new MouseEvent('mouseup', {});
                    this.canvas.dispatchEvent(mouseEvent);
                });
            }

            getCanvasPoint(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY,
                    time: performance.now()
                };
            }

            calculatePressure(velocity, isEnding = false) {
                // 스트로크 끝에서는 압력을 점진적으로 감소
                if (isEnding) {
                    return Math.max(0.1, this.lastPressure * 0.3);
                }
                
                // 속도 히스토리 관리 (최근 5개 포인트)
                this.velocityHistory.push(velocity);
                if (this.velocityHistory.length > 5) {
                    this.velocityHistory.shift();
                }
                
                // 평균 속도 계산 (급격한 변화 방지)
                const avgVelocity = this.velocityHistory.reduce((sum, v) => sum + v, 0) / this.velocityHistory.length;
                
                // 속도 기반 압력 계산
                const maxVelocity = 800;
                const normalizedVelocity = Math.min(avgVelocity / maxVelocity, 1);
                const basePressure = 0.4;
                const pressureRange = 0.5;
                
                // 방향 전환을 고려한 압력 계산
                let rawPressure = basePressure + pressureRange * (1 - normalizedVelocity) * this.pressureSensitivity;
                
                // 압력 스무딩 (이전 압력과 부드럽게 블렌딩)
                const pressureSmoothingFactor = 0.7;
                const smoothedPressure = this.lastPressure * pressureSmoothingFactor + rawPressure * (1 - pressureSmoothingFactor);
                
                this.lastPressure = smoothedPressure;
                return Math.max(0.2, Math.min(1.0, smoothedPressure));
            }

            calculateVelocity(currentPoint, lastPoint) {
                if (!lastPoint) return 0;
                
                const dx = currentPoint.x - lastPoint.x;
                const dy = currentPoint.y - lastPoint.y;
                const dt = Math.max(currentPoint.time - lastPoint.time, 1);
                
                const distance = Math.sqrt(dx * dx + dy * dy);
                const currentVelocity = distance / dt * 1000; // pixels per second
                
                // 속도 스무딩 (급격한 변화 방지)
                const velocitySmoothingFactor = 0.8;
                this.velocity = this.velocity * velocitySmoothingFactor + currentVelocity * (1 - velocitySmoothingFactor);
                
                return this.velocity;
            }

            predictNextPoint(currentPoint, lastPoint) {
                if (!lastPoint) return currentPoint;
                
                const dx = currentPoint.x - lastPoint.x;
                const dy = currentPoint.y - lastPoint.y;
                
                // 예측 거리는 현재 속도에 비례
                const predictionFactor = Math.min(this.velocity / 500, 2);
                
                return {
                    x: currentPoint.x + dx * predictionFactor,
                    y: currentPoint.y + dy * predictionFactor,
                    time: currentPoint.time
                };
            }

            smoothPoint(currentPoint, lastPoint, factor) {
                if (!lastPoint) return currentPoint;
                
                return {
                    x: lastPoint.x + (currentPoint.x - lastPoint.x) * factor,
                    y: lastPoint.y + (currentPoint.y - lastPoint.y) * factor,
                    time: currentPoint.time
                };
            }

            startDrawing(e) {
                this.isDrawing = true;
                const point = this.getCanvasPoint(e);
                this.currentStroke = [point];
                this.lastPoint = point;
                this.lastTime = point.time;
                
                // 압력 관련 변수 초기화
                this.velocityHistory = [0];
                this.pressureHistory = [];
                this.lastPressure = 0.5;
                this.velocity = 0;
                
                document.getElementById('activePoints').textContent = '1';
            }

            draw(e) {
                if (!this.isDrawing) return;

                const rawPoint = this.getCanvasPoint(e);
                
                // 속도 계산
                this.velocity = this.calculateVelocity(rawPoint, this.lastPoint);
                
                // 스무딩 적용
                const smoothedPoint = this.smoothPoint(rawPoint, this.lastPoint, this.smoothingFactor);
                
                // 압력 계산
                const pressure = this.calculatePressure(this.velocity);
                
                // 예측 포인트 계산 (렌더링하지 않음)
                this.predictedPoint = this.predictNextPoint(smoothedPoint, this.lastPoint);
                
                // 베지어 곡선으로 부드러운 선 그리기
                if (this.lastPoint) {
                    this.drawSmoothLine(this.lastPoint, smoothedPoint, pressure);
                }
                
                this.currentStroke.push(smoothedPoint);
                this.lastPoint = smoothedPoint;
                
                // UI 업데이트
                document.getElementById('activePoints').textContent = this.currentStroke.length;
            }

            drawSmoothLine(from, to, pressure) {
                const distance = Math.sqrt(
                    Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2)
                );
                
                // 거리가 너무 작으면 스킵
                if (distance < 1) return;
                
                // 압력에 따른 선 굵기
                const lineWidth = this.brushSize * pressure;
                
                // 첫 번째 점인 경우 직선으로 시작
                if (this.currentStroke.length === 0) {
                    this.ctx.lineWidth = lineWidth;
                    this.ctx.strokeStyle = this.color;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(from.x, from.y);
                    this.ctx.lineTo(to.x, to.y);
                    this.ctx.stroke();
                    return;
                }
                
                // 베지어 곡선 제어점 계산
                const cp1x = from.x + (to.x - from.x) * 0.3;
                const cp1y = from.y + (to.y - from.y) * 0.3;
                const cp2x = from.x + (to.x - from.x) * 0.7;
                const cp2y = from.y + (to.y - from.y) * 0.7;
                
                this.ctx.lineWidth = lineWidth;
                this.ctx.strokeStyle = this.color;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                this.ctx.beginPath();
                this.ctx.moveTo(from.x, from.y);
                this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, to.x, to.y);
                this.ctx.stroke();
            }

            stopDrawing() {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                
                // 자연스러운 스트로크 끝처리 - 마지막 몇 개의 점에 테이퍼 적용
                if (this.currentStroke.length > 2 && this.lastPoint) {
                    this.addNaturalEnding();
                }
                
                // 통계 업데이트
                const strokeLength = this.currentStroke.length;
                const avgVelocity = Math.round(this.velocity);
                document.getElementById('lastStroke').textContent = 
                    `${strokeLength}점, ${avgVelocity}px/s`;
                document.getElementById('activePoints').textContent = '0';
                
                this.currentStroke = [];
                this.lastPoint = null;
                this.predictedPoint = null;
            }

            addNaturalEnding() {
                // 마지막 포인트부터 점진적으로 압력을 줄여서 자연스러운 끝처리
                if (this.currentStroke.length < 3) return;
                
                const endPoints = 3; // 마지막 3개 점에 테이퍼 적용
                const startIndex = Math.max(0, this.currentStroke.length - endPoints);
                
                for (let i = startIndex; i < this.currentStroke.length - 1; i++) {
                    const progress = (i - startIndex) / endPoints;
                    const taperPressure = this.calculatePressure(this.velocity, true) * (1 - progress * 0.6);
                    
                    const from = this.currentStroke[i];
                    const to = this.currentStroke[i + 1];
                    
                    if (from && to) {
                        this.ctx.lineWidth = this.brushSize * Math.max(0.1, taperPressure);
                        this.ctx.strokeStyle = this.color;
                        this.ctx.lineCap = 'round';
                        this.ctx.lineJoin = 'round';
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(from.x, from.y);
                        this.ctx.lineTo(to.x, to.y);
                        this.ctx.stroke();
                    }
                }
            }

            startRenderLoop() {
                const renderFrame = () => {
                    // FPS 계산
                    this.frameCount++;
                    const now = performance.now();
                    if (now - this.lastFpsTime >= 1000) {
                        const fps = Math.round(this.frameCount * 1000 / (now - this.lastFpsTime));
                        document.getElementById('fps').textContent = fps;
                        this.frameCount = 0;
                        this.lastFpsTime = now;
                    }
                    
                    requestAnimationFrame(renderFrame);
                };
                
                renderFrame();
            }

            // 설정 업데이트 메서드들
            setBrushSize(size) {
                this.brushSize = parseFloat(size);
            }

            setColor(color) {
                this.color = color;
            }

            setSmoothing(value) {
                this.smoothingFactor = parseFloat(value) / 10;
            }

            setPressureSensitivity(value) {
                this.pressureSensitivity = parseFloat(value) / 10;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }

        // 초기화
        const canvas = document.getElementById('drawingCanvas');
        const pen = new NaturalPen(canvas);

        // 컨트롤 이벤트 리스너
        document.getElementById('brushSize').addEventListener('input', (e) => {
            pen.setBrushSize(e.target.value);
            document.getElementById('brushSizeValue').textContent = e.target.value + 'px';
        });

        document.getElementById('color').addEventListener('input', (e) => {
            pen.setColor(e.target.value);
        });

        document.getElementById('smoothing').addEventListener('input', (e) => {
            pen.setSmoothing(e.target.value);
            document.getElementById('smoothingValue').textContent = e.target.value;
        });

        document.getElementById('pressureSensitivity').addEventListener('input', (e) => {
            pen.setPressureSensitivity(e.target.value);
            document.getElementById('pressureValue').textContent = e.target.value;
        });

        function clearCanvas() {
            pen.clear();
            document.getElementById('lastStroke').textContent = '-';
            document.getElementById('activePoints').textContent = '0';
        }

        // 초기 값 설정
        document.getElementById('brushSizeValue').textContent = '3px';
        document.getElementById('smoothingValue').textContent = '5';
        document.getElementById('pressureValue').textContent = '7';
    </script>
</body>
</html>